#!/bin/bash

TEST_CMD="/usr/bin/cp-test -t -u -r"
BUILD='false'
DEV='false'
DIR="${BASH_SOURCE[0]}"

usage() {
	cat << USAGE

USAGE: test [OPTIONS]

OPTIONS:
  -b        rebuilds the candlepin container
  -c CMD    sets the command to be run by the container
              default: $TEST_CMD
  -d        dev mode. Mounts this repo to /candlepin-dev
  -m        use mysql
  -o        use oracle
  -p        use postgres

USAGE
}

while getopts ":bc:d" opt; do
  case $opt in
    b) BUILD=true;;
    c) TEST_CMD="$OPTARG";;
    d) DEV=true;;
		m) COMPOSE_ARGS="-f $DIR/docker-compose-mysql.yml";;
		o) COMPOSE_ARGS="-f $DIR/docker-compose-oracle.yml";;
		p) COMPOSE_ARGS="-f $DIR/docker-compose-postgres.yml";;
    \?)
      echo "Invalid option: -$OPTARG" >&2
			usage
      exit 1
      ;;
    :)
      echo "Option -$OPTARG requires an argument." >&2
			usage
      exit 1
      ;;
  esac
done

if [ $DEV = true ]; then
	if [ -z $COMPOSE_ARGS ]; then
		COMPOSE_ARGS="-f $DIR/docker-compose-dev.yml"
	else
		COMPOSE_ARGS="$(echo $COMPOSE_ARGS | sed -e 's/.yml$/-dev.yml/')"
	fi
  # idea here was to use env var in docker compose file
  # but won't really work until version 2.1 due to default vars: ${VAR-default}
  # hard coding relative path in compose.yml for now
	# $MOUNT="-v $(git rev-parse --show-toplevel):/candlepin-dev"
fi

docker-compose stop
docker-compose rm -f -a
[ $BUILD = true ] && docker-compose build
docker-compose $COMPOSE_ARGS run --rm candlepin $TEST_CMD
RETVAL=$?
docker-compose stop

exit $RETVAL
